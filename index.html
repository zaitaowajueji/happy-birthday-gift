<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy Birthday</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        
        /* 错误日志框：如果再出问题，这里会显示红字报错，而不是黑屏 */
        #debug-console {
            position: absolute; top: 0; left: 0; padding: 10px; color: red;
            background: rgba(0,0,0,0.8); z-index: 9999; display: none;
            font-family: monospace; pointer-events: none; white-space: pre-wrap;
        }

        #instruction {
            position: absolute; bottom: 15%; width: 100%; text-align: center;
            color: #d4af37; font-family: sans-serif; letter-spacing: 4px;
            font-size: 14px; pointer-events: none; animation: pulse 2s infinite;
            text-transform: uppercase;
        }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="debug-console"></div>
    <div id="instruction">Tap the Box</div>
    <div id="canvas-container"></div>

    <script>
        window.addEventListener('error', (e) => {
            const d = document.getElementById('debug-console');
            d.style.display = 'block';
            d.innerText += `Error: ${e.message}\n`;
        });
        window.addEventListener('unhandledrejection', (e) => {
            const d = document.getElementById('debug-console');
            d.style.display = 'block';
            d.innerText += `Promise Error: ${e.reason}\n`;
        });
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 场景 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02); 

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 30);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 灯光 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.05); // 暗一点，突出光辉
        scene.add(ambientLight);

        const mainLight = new THREE.PointLight(0xffd700, 150, 100);
        mainLight.position.set(5, 5, 10);
        scene.add(mainLight);
        
        const purpleLight = new THREE.PointLight(0x8800ff, 50, 100); // 加点紫色氛围光
        purpleLight.position.set(-10, -5, 5);
        scene.add(purpleLight);

        // --- 材质 ---
        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xffcc00,
            metalness: 1.0,
            roughness: 0.1,
            emissive: 0x221100
        });

        // --- 核心：礼盒 ---
        const geometryBox = new THREE.BoxGeometry(3, 3, 3);
        const giftBox = new THREE.Mesh(geometryBox, goldMaterial);
        giftBox.rotation.set(0.5, 0.5, 0);
        scene.add(giftBox);

        // --- 核心：文字 (Canvas 生成) ---
        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff'; 
            ctx.font = 'bold 100px "Times New Roman", serif'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text.split('\n')[0], 512, 180);
            ctx.fillText(text.split('\n')[1], 512, 320);
            return new THREE.CanvasTexture(canvas);
        }

        const textMat = new THREE.MeshBasicMaterial({
            map: createTextTexture("HAPPY\nBIRTHDAY"), 
            transparent: true,
            color: 0xffd700,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });
        
        const textPlane = new THREE.Mesh(new THREE.PlaneGeometry(12, 6), textMat);
        textPlane.position.z = -100;
        textPlane.visible = false;
        scene.add(textPlane);

        // --- 粒子 ---
        const particlesGeo = new THREE.BufferGeometry();
        const pCount = 800;
        const pPos = new Float32Array(pCount * 3);
        for(let i=0; i<pCount*3; i++) pPos[i] = (Math.random()-0.5) * 50;
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        const particles = new THREE.Points(particlesGeo, new THREE.PointsMaterial({
            color: 0xffd700, size: 0.15, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending
        }));
        scene.add(particles);

        // --- 后处理 (Bloom) ---
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;
        bloomPass.threshold = 0.1;
        composer.addPass(bloomPass);

        // --- 交互 ---
        let isOpened = false;
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        // 兼容移动端触摸和鼠标点击
        window.addEventListener('pointerdown', (event) => {
            if(isOpened) return;
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            if (raycaster.intersectObject(giftBox).length > 0) {
                openGift();
            }
        });

        function openGift() {
            isOpened = true;
            document.getElementById('instruction').style.opacity = 0;
            
            const start = Date.now();
            function animateOpen() {
                const now = Date.now();
                const progress = Math.min((now - start) / 1000, 1);
                
                if(progress < 1) {
                    giftBox.rotation.x += 0.2;
                    giftBox.rotation.y += 0.2;
                    giftBox.scale.setScalar(1 - progress);
                    bloomPass.strength = 1.2 + progress * 3; 
                } else {
                    giftBox.visible = false;
                    textPlane.visible = true;
                    
                    const textP = Math.min((now - start - 1000) / 1500, 1);
                    if(textP > 0) {
                        textPlane.position.z = -50 + (40 * (1 - Math.pow(1 - textP, 3))); 
                        bloomPass.strength = 4.2 - textP * 3; 
                    }
                }
                if((now - start) < 4000) requestAnimationFrame(animateOpen);
            }
            animateOpen();
        }

        // --- 渲染循环 ---
        function animate() {
            requestAnimationFrame(animate);
            if(!isOpened) {
                giftBox.rotation.y += 0.01;
                giftBox.rotation.x = Math.sin(Date.now()*0.001)*0.1;
            } else {
                textPlane.rotation.z = Math.sin(Date.now()*0.001)*0.05;
            }
            particles.rotation.y += 0.001;
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
