<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Arix's Surprise</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a0b0b; touch-action: none; }
        
        /* 氛围感 Loading */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #1a0b0b; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 999;
            transition: opacity 1.5s ease-out;
        }
        .loader-text {
            color: #FFD700; font-family: 'Times New Roman', serif;
            font-size: 16px; letter-spacing: 4px; text-transform: uppercase;
            animation: pulse 2s infinite; margin-top: 20px;
        }
        
        /* 交互提示 */
        #instruction {
            position: absolute; bottom: 15%; width: 100%; text-align: center;
            color: rgba(255, 248, 232, 0.6); font-family: sans-serif;
            font-size: 12px; letter-spacing: 2px; pointer-events: none;
            opacity: 0; transition: opacity 2s;
        }

        @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }
    </style>
    
    <script src="https://lib.baomitu.com/three.js/r128/three.min.js"></script>
    <script src="https://lib.baomitu.com/three.js/r128/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://lib.baomitu.com/three.js/r128/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://lib.baomitu.com/three.js/r128/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://lib.baomitu.com/three.js/r128/examples/js/shaders/CopyShader.js"></script>
    <script src="https://lib.baomitu.com/three.js/r128/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://lib.baomitu.com/three.js/r128/examples/js/postprocessing/UnrealBloomPass.js"></script>
</head>
<body>

    <div id="loader">
        <div style="width: 40px; height: 40px; border: 2px solid #FFD700; transform: rotate(45deg);"></div>
        <div class="loader-text">Arix Signature</div>
    </div>
    
    <div id="instruction">TAP TO SCATTER / ASSEMBLE</div>
    <div id="canvas-container"></div>

    <script>
        // --- 配置参数 ---
        const CONFIG = {
            colors: {
                cream: 0xFFF8E8, // 奶油白
                gold: 0xFFD700,  // 奢华金
                red: 0xD90429,   // 莓果红
                bg: 0x1a0b0b     // 深红褐背景
            }
        };

        // --- 场景初始化 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.02);
        scene.background = new THREE.Color(CONFIG.colors.bg);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 25);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 灯光系统 (电影级) ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        // 主光：暖金
        const mainLight = new THREE.PointLight(CONFIG.colors.gold, 1.2, 50);
        mainLight.position.set(5, 10, 5);
        scene.add(mainLight);

        // 补光：柔白
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
        fillLight.position.set(-5, 0, 5);
        scene.add(fillLight);

        // --- 材质定义 ---
        const creamMat = new THREE.MeshStandardMaterial({
            color: CONFIG.colors.cream, roughness: 0.7, metalness: 0.1
        });
        const goldMat = new THREE.MeshStandardMaterial({
            color: CONFIG.colors.gold, roughness: 0.1, metalness: 0.9, emissive: 0x332200
        });
        const redMat = new THREE.MeshStandardMaterial({
            color: CONFIG.colors.red, roughness: 0.3, metalness: 0.2
        });

        // --- 核心：可变形物体系统 ---
        // 我们不创建单一网格，而是创建一堆“碎片”，它们有两个位置：散落态 和 聚合态
        const parts = [];
        const group = new THREE.Group();
        scene.add(group);

        function createPart(geometry, material, finalPos, finalRot, scale) {
            const mesh = new THREE.Mesh(geometry, material);
            
            // 1. 设定聚合态(目标)属性
            const targetPos = finalPos.clone();
            const targetRot = finalRot ? finalRot.clone() : new THREE.Euler(0,0,0);
            
            // 2. 设定散落态(初始)属性 - 随机分布在空中
            const randomAngle = Math.random() * Math.PI * 2;
            const randomRadius = 15 + Math.random() * 10;
            const startPos = new THREE.Vector3(
                Math.cos(randomAngle) * randomRadius,
                (Math.random() - 0.5) * 20,
                Math.sin(randomAngle) * randomRadius
            );
            const startRot = new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0);

            // 初始状态设为散落
            mesh.position.copy(startPos);
            mesh.rotation.copy(startRot);
            mesh.scale.setScalar(scale || 1);

            // 存入数组
            parts.push({
                mesh: mesh,
                startPos: startPos,
                targetPos: targetPos,
                startRot: startRot,
                targetRot: targetRot,
                delay: Math.random() * 1.5 // 随机延迟，让飞入更有层次感
            });

            group.add(mesh);
        }

        // --- 构建蛋糕结构 (定义目标位置) ---
        
        // 1. 底层蛋糕胚 (分块构建，为了飞入效果)
        const baseGeo = new THREE.CylinderGeometry(3, 3, 2, 8); // 8边形模拟切块感
        for(let i=0; i<8; i++) {
            // 这里用一点数学技巧把圆柱拆成片(视觉上的欺骗，实际用小圆柱代替)
            const angle = (i / 8) * Math.PI * 2;
            const x = Math.cos(angle) * 1.5;
            const z = Math.sin(angle) * 1.5;
            createPart(
                new THREE.CylinderGeometry(0.8, 0.8, 2, 16), 
                creamMat, 
                new THREE.Vector3(x, -1, z), 
                null, 1.8
            );
        }

        // 2. 顶层蛋糕胚
        for(let i=0; i<6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            createPart(
                new THREE.CylinderGeometry(0.5, 0.5, 1.5, 16),
                creamMat,
                new THREE.Vector3(Math.cos(angle)*0.8, 1, Math.sin(angle)*0.8),
                null, 1.5
            );
        }

        // 3. 金色装饰球 (珍珠)
        const pearlGeo = new THREE.SphereGeometry(0.15, 16, 16);
        for(let i=0; i<20; i++) {
            const angle = (i / 20) * Math.PI * 2;
            createPart(
                pearlGeo, goldMat,
                new THREE.Vector3(Math.cos(angle)*3, -0.2, Math.sin(angle)*3), // 放在底层边缘
                null, 1
            );
        }

        // 4. 莓果装饰 (顶层)
        const berryGeo = new THREE.SphereGeometry(0.3, 16, 16);
        createPart(berryGeo, redMat, new THREE.Vector3(0, 2, 0), null, 1.2); // 顶端红果
        for(let i=0; i<5; i++) {
            const angle = (i/5) * Math.PI * 2;
            createPart(berryGeo, redMat, new THREE.Vector3(Math.cos(angle)*1.2, 1.8, Math.sin(angle)*1.2), null, 1);
        }

        // 5. 蜡烛 (主体)
        createPart(
            new THREE.CylinderGeometry(0.1, 0.1, 1.5, 16),
            goldMat,
            new THREE.Vector3(0, 3, 0),
            null, 1
        );
        // 蜡烛火焰 (用辉光点模拟)
        const flameGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const flameMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
        createPart(flameGeo, flameMat, new THREE.Vector3(0, 3.8, 0), null, 1);


        // --- 文字：Happy Birthday ---
        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 100px "Times New Roman"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = "#ffaa00"; ctx.shadowBlur = 20;
            ctx.fillText(text, 512, 128);
            return new THREE.CanvasTexture(canvas);
        }
        const textGeo = new THREE.PlaneGeometry(8, 2);
        const textMat = new THREE.MeshBasicMaterial({ 
            map: createTextTexture("HAPPY BIRTHDAY"), 
            transparent: true, side: THREE.DoubleSide, blending: THREE.AdditiveBlending 
        });
        createPart(textGeo, textMat, new THREE.Vector3(0, -3.5, 2), new THREE.Euler(-0.2, 0, 0), 1);


        // --- 后处理 (辉光 Bloom) ---
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(new THREE.RenderPass(scene, camera));
        
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.2; // 适中的辉光
        bloomPass.radius = 0.8;
        composer.addPass(bloomPass);


        // --- 动画逻辑 ---
        let isAssembled = false; // 当前状态
        let animationTime = 0;   // 动画进度计时
        
        // 页面加载完成后自动聚合
        window.onload = () => {
            setTimeout(() => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => { 
                    document.getElementById('loader').style.display = 'none';
                    document.getElementById('instruction').style.opacity = 1;
                    isAssembled = true; // 触发聚合
                }, 1500);
            }, 1000);
        };

        // 点击切换状态
        window.addEventListener('mousedown', () => { isAssembled = !isAssembled; });
        window.addEventListener('touchstart', () => { isAssembled = !isAssembled; });

        function animate() {
            requestAnimationFrame(animate);

            const dt = 0.016; // 假设60fps
            
            // 缓动动画核心
            parts.forEach(p => {
                // 根据状态决定目标
                const targetP = isAssembled ? p.targetPos : p.startPos;
                const targetR = isAssembled ? p.targetRot : p.startRot;
                
                // 简单的平滑插值 (Lerp)
                // 这里加一点 math.max 保证在散开时有个延迟感
                const speed = isAssembled ? 0.03 : 0.05; 
                
                p.mesh.position.lerp(targetP, speed);
                
                // 旋转插值
                p.mesh.rotation.x += (targetR.x - p.mesh.rotation.x) * speed;
                p.mesh.rotation.y += (targetR.y - p.mesh.rotation.y) * speed;
                p.mesh.rotation.z += (targetR.z - p.mesh.rotation.z) * speed;
            });

            // 整体缓慢旋转展示
            if(isAssembled) {
                group.rotation.y += 0.005;
            } else {
                group.rotation.y += 0.001;
            }

            // 摄像机微动 (呼吸感)
            const time = Date.now() * 0.001;
            camera.position.y = 5 + Math.sin(time * 0.5) * 1;

            composer.render();
        }
        animate();

        // 窗口自适应
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
